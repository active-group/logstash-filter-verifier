// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"sync"

	"github.com/magnusbaeck/logstash-filter-verifier/v2/internal/daemon/controller"
)

// Ensure, that InstanceMock does implement controller.Instance.
// If this is not the case, regenerate this file with moq.
var _ controller.Instance = &InstanceMock{}

// InstanceMock is a mock implementation of controller.Instance.
//
// 	func TestSomethingThatUsesInstance(t *testing.T) {
//
// 		// make and configure a mocked controller.Instance
// 		mockedInstance := &InstanceMock{
// 			ConfigReloadFunc: func() error {
// 				panic("mock out the ConfigReload method")
// 			},
// 			ShutdownFunc: func()  {
// 				panic("mock out the Shutdown method")
// 			},
// 			StartFunc: func(controllerMoqParam *controller.Controller, workdir string) error {
// 				panic("mock out the Start method")
// 			},
// 		}
//
// 		// use mockedInstance in code that requires controller.Instance
// 		// and then make assertions.
//
// 	}
type InstanceMock struct {
	// ConfigReloadFunc mocks the ConfigReload method.
	ConfigReloadFunc func() error

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func()

	// StartFunc mocks the Start method.
	StartFunc func(controllerMoqParam *controller.Controller, workdir string) error

	// calls tracks calls to the methods.
	calls struct {
		// ConfigReload holds details about calls to the ConfigReload method.
		ConfigReload []struct{}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct{}
		// Start holds details about calls to the Start method.
		Start []struct {
			// ControllerMoqParam is the controllerMoqParam argument value.
			ControllerMoqParam *controller.Controller
			// Workdir is the workdir argument value.
			Workdir string
		}
	}
	lockConfigReload sync.RWMutex
	lockShutdown     sync.RWMutex
	lockStart        sync.RWMutex
}

// ConfigReload calls ConfigReloadFunc.
func (mock *InstanceMock) ConfigReload() error {
	if mock.ConfigReloadFunc == nil {
		panic("InstanceMock.ConfigReloadFunc: method is nil but Instance.ConfigReload was just called")
	}
	callInfo := struct{}{}
	mock.lockConfigReload.Lock()
	mock.calls.ConfigReload = append(mock.calls.ConfigReload, callInfo)
	mock.lockConfigReload.Unlock()
	return mock.ConfigReloadFunc()
}

// ConfigReloadCalls gets all the calls that were made to ConfigReload.
// Check the length with:
//     len(mockedInstance.ConfigReloadCalls())
func (mock *InstanceMock) ConfigReloadCalls() []struct{} {
	var calls []struct{}
	mock.lockConfigReload.RLock()
	calls = mock.calls.ConfigReload
	mock.lockConfigReload.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *InstanceMock) Shutdown() {
	if mock.ShutdownFunc == nil {
		panic("InstanceMock.ShutdownFunc: method is nil but Instance.Shutdown was just called")
	}
	callInfo := struct{}{}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//     len(mockedInstance.ShutdownCalls())
func (mock *InstanceMock) ShutdownCalls() []struct{} {
	var calls []struct{}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *InstanceMock) Start(controllerMoqParam *controller.Controller, workdir string) error {
	if mock.StartFunc == nil {
		panic("InstanceMock.StartFunc: method is nil but Instance.Start was just called")
	}
	callInfo := struct {
		ControllerMoqParam *controller.Controller
		Workdir            string
	}{
		ControllerMoqParam: controllerMoqParam,
		Workdir:            workdir,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(controllerMoqParam, workdir)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//     len(mockedInstance.StartCalls())
func (mock *InstanceMock) StartCalls() []struct {
	ControllerMoqParam *controller.Controller
	Workdir            string
} {
	var calls []struct {
		ControllerMoqParam *controller.Controller
		Workdir            string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}
